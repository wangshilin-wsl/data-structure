package competition.likou_2023_03_05;

/*力扣：6309. 分割数组使乘积互质 显示英文描述
        给你一个长度为 n 的整数数组 nums ，下标从 0 开始。

        如果在下标 i 处 分割 数组，其中 0 <= i <= n - 2 ，使前 i + 1 个元素的乘积和剩余元素的乘积互质，则认为该分割 有效 。

        例如，如果 nums = [2, 3, 3] ，那么在下标 i = 0 处的分割有效，因为 2 和 9 互质，而在下标 i = 1 处的分割无效，因为 6 和 3 不互质。在下标 i = 2 处的分割也无效，因为 i == n - 1 。
        返回可以有效分割数组的最小下标 i ，如果不存在有效分割，则返回 -1 。

        当且仅当 gcd(val1, val2) == 1 成立时，val1 和 val2 这两个值才是互质的，其中 gcd(val1, val2) 表示 val1 和 val2 的最大公约数。



        示例 1：



        输入：nums = [4,7,8,15,3,5]
        输出：2
        解释：上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。
        唯一一个有效分割位于下标 2 。
        示例 2：



        输入：nums = [4,7,15,8,3,5]
        输出：-1
        解释：上表展示了每个下标 i 处的前 i + 1 个元素的乘积、剩余元素的乘积和它们的最大公约数的值。
        不存在有效分割。


        提示：

        n == nums.length
        1 <= n <= 104
        1 <= nums[i] <= 106*/
public class FindValidSplit {
    public static void main(String[] args) {
        System.out.println(new FindValidSplit().findValidSplit(new int[]{557663,280817,472963,156253,273349,884803,756869,763183,557663,964357,821411,887849,891133,453379,464279,574373,852749,15031,156253,360169,526159,410203,6101,954851,860599,802573,971693,279173,134243,187367,896953,665011,277747,439441,225683,555143,496303,290317,652033,713311,230107,770047,308323,319607,772907,627217,119311,922463,119311,641131,922463,404773,728417,948281,612373,857707,990589,12739,9127,857963,53113,956003,363397,768613,47981,466027,981569,41597,87149,55021,600883,111953,119083,471871,125641,922463,562577,269069,806999,981073,857707,831587,149351,996461,432457,10903,921091,119083,72671,843289,567323,317003,802129,612373}));
    }

    public int findValidSplit(int[] nums) {
        int n = nums.length;
        //枚举所有i的位置，它的两边每个元素都要互相互质
        for (int i = 0; i <= n - 2; i++) {
            for (int j =  i + 1; j < n; j++) {
                //i,j不为互质的，那么i只能往后走，并且需要把j包含进去
               if (gcd(nums[i], nums[j]) != 1) {
                   i = j;
               }
            }
        }


        return -1;
    }


    //暴力法，部分超时
    //枚举所有i的位置，它的两边每个元素都要互相互质
    public int findValidSplit1(int[] nums) {
        int n = nums.length;
        for (int i = 0; i <= n - 2; i++) {
            boolean flag = true;
            for (int j = 0; j <= i; j++) {
                for (int k = i + 1; k < n; k++) {
                   if (gcd(nums[j], nums[k]) != 1) {
                       flag = false;
                       break;
                   }
                }
                if (!flag) {
                    break;
                }
            }
            if (flag) {
                return i;
            }
        }
        return -1;
    }
    int gcd(int a, int b) {
        return b == 0 ? a : (gcd(b, a % b));
    }
}
